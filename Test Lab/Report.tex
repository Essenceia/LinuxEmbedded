\documentclass[a4paper,oneside,onecolumn]{article}
\usepackage[utf8x]{inputenc}
\usepackage{mathtools}
\usepackage{color}
\usepackage{siunitx}
\usepackage{microtype}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage{amssymb}
\usepackage{}
\usepackage[head=12pt,hmargin=2.5cm,vmargin=2.5cm]{geometry}

\renewcommand*\lstlistingname{Code Snippet}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}

\DisableLigatures[>,<]{encoding = T1,family=tt*} %

\definecolor{codegray}{gray}{0.9}
\newcommand{\code}[1]{\colorbox{codegray}{\texttt{#1}}}

\pagestyle{fancy}

\begin{document}

\title{Test Lab \\ Linux Shell / GNU Make \\ Embedded Linux}
\author{Julia Desmazes \\ Michael Nissen}
\date{\today}
\maketitle
\bigskip

\section*{Command line, environment variables, and user permissions}

\noindent 
\textbf{1. In the bash prompt, what is the meaning of the character \~{} ?}
\newline
\newline
The tilde (\~{}) character refers to the users home directory. The full path is \texttt{/home/user}.
\newline
\newline
\noindent
\textbf{2. Explain the behaviour of running in the order \code{VV=3}, \code{export VV}, \code{bash}, \code{unset VV}, \code{exit} and finally \code{echo \$VV}?}
\newline
\newline
Environment variables is a value, named at runtime, that can affect the way running processes behave. A running process will be able to query the value of an environment variable for example, to discover a location to store files. When creating an environment variable, it will persist in the shell in which it was initalised.
\newline
When exporting the creatied environment variable by using \code{export VARNAME}, it sets the environment variable not only for current shell, but all other processes started from that shell.
\begin{itemize}
	\item Set local variable VV to 3
	\item Export local variable as environment variable
	\item Enter the bash shell
	\item Unest the local variable
	\item Exit the bash shell
	\item Display the environment variable
\end{itemize}
\noindent
\textbf{3. How to run \texttt{/home/user/ls} instead of \texttt{/usr/bin/ls} automatically by typing \code{ls} without changin the behaviour of the other commands?}
\newline
\newline
An easy way to achive this kind of behaviour, is to create a shell alias. A shell alias is simply a shortcut to reference a command. It can be used to avoid typing long commands or as a mean to run increase efficiency.
In this example, we want to run the \texttt{/home/user/ls} command instead of the buildin one located in \texttt{/usr/bin/ls}. As the \texttt{/usr/bin} folder is added to the path of the shell, one is able to run any script from that folder by simply entering the name of that script.
\newline
As we don't necessarily want to add the \texttt{home/user} folder to the path, we can create an alias to the specific file we need. 
\newline
\newline
One can create an alias using echo and redirecting it to the shell configuration file: 
\newline
\code{echo alias 'ls="/home/user/ls"' >> .zshrc} where the last file is your shell configuration file.
\newline
\newline
\noindent
\textbf{4. How to provide \texttt{file.txt} as input of the command \code{flex} and copy its \texttt{stderr} to \texttt{resu.txt}?}
\newline
\newline
3 different streams. Use 2> to redirect the content on stderr. (-p writes the performance report to stdderr)
\newline
\code{flex -p file.txt 2> resu.txt }
\newline
\newline
\noindent
\textbf{5. Propose a command that displays the middle line of \texttt{/etc/passwd} ?}
\newline
\newline
\newline
\newline
\noindent
\textbf{6. How to change the owner of a first file to the owner of a second one by using a command substitution based on the command \code{ls} and \code{cut} ?}
\newline
\newline
Easy way is to just use the build in functionality of \code{chown}. No need to reinvent the wheel:
\newline
\code{chown --reference=result.txt file.txt}

\section*{The \code{grep}/\code{sed} and Ragular Expressions}

\section*{Shell Script}

\section*{GNU Make}

\section*{Managing Process, System Call \code{fork()}}

\noindent
The system call \code{fork()} is used to create processes and returns a process ID. When calling \code{fork()}, it creates a new process which becomes a \textit{child} process of the caller. After a child process has been created, both the \textit{child} and \textit{parent} process will execute the next instruction following the \code{fork()} system call. Therefore, one has to distingush the difference between the two processes.
\newline
This can be done by testing the process ID returned by the system call.
\newline
\newline
If \code{fork()} returns a negative value, the creation of a child process was unsuccessful. It will return a zero to the newly created \textit{child} process, and it will return a possitive value, the \texttt{pid} of the \textit{child} process, to the parent.
\newline
\newline
Therefore it is simple to check what which is the child process - this can be seen in Code Snippet 1 below.
\begin{lstlisting}[language=c, caption=Managing system calls]
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main() {

    // The process ID
    pid_t pid;

    // Store the process ID
    pid = fork();

    // Check for the process ID
    if (pid == 0) {

        // Child process

        // Create a new fork
        pid = fork();

        // Check for the process ID
        if (pid == 0) {

            // Grand child process
            printf("Child of Child");
        } else {

            // Child process
            printf("Child");
        }
    } else {

        // This is the parent process
        printf("Parent");
    }
}
\end{lstlisting}



\end{document}